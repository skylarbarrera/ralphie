# Senior Engineer Code Quality Standards

This document defines the code quality standards that Ralphie aims to achieve. Code generated by Ralphie should meet "senior engineer" expectations: maintainable, well-architected, properly tested, secure, and using appropriate tools.

## Table of Contents

- [What Makes "Senior Engineer" Code](#what-makes-senior-engineer-code)
- [Tool Selection Criteria](#tool-selection-criteria)
- [Architecture Principles](#architecture-principles)
- [Testing Requirements](#testing-requirements)
- [Security Checklist](#security-checklist)
- [Performance Guidelines](#performance-guidelines)
- [Examples: Good vs Bad](#examples-good-vs-bad)

---

## What Makes "Senior Engineer" Code

Senior engineer code is characterized by:

### 1. **Clarity and Intent**
- Code communicates what it does and why
- Variable and function names are descriptive
- Complex logic includes explanatory comments
- Functions have single, clear responsibilities

### 2. **Proper Abstraction**
- Separation of concerns (business logic, presentation, data)
- Clear interfaces between modules
- Dependencies point in the right direction (high-level → low-level)
- Reusable components with well-defined contracts

### 3. **Quality Foundations**
- Comprehensive test coverage (>80%)
- Type safety (TypeScript, Python type hints)
- Error handling is consistent and intentional
- No shortcuts or "will fix later" code

### 4. **Production Ready**
- Secure by default
- Performant (avoids obvious bottlenecks)
- Observable (proper logging, error reporting)
- Documented (README, API docs, architecture decisions)

### 5. **Tool Selection**
- Uses established, well-maintained libraries
- Prefers industry-standard solutions over custom implementations
- Chooses tools appropriate for the problem scale
- Avoids unnecessary dependencies

---

## Tool Selection Criteria

When choosing libraries and tools, consider:

### 1. **Best-in-Class First**
Always prefer established, best-in-class tools over custom implementations:

- **Validation**: Zod (TypeScript), Pydantic (Python) — not manual checks
- **Date/Time**: date-fns, Temporal API — not manual parsing
- **HTTP**: axios, ky — not raw fetch wrappers
- **Testing**: Vitest/Jest, Pytest — not custom test runners
- **ORM**: Prisma (TypeScript), SQLAlchemy (Python) — not raw SQL builders

### 2. **Evaluation Framework**

| Criterion | What to Consider |
|-----------|-----------------|
| **Performance** | Benchmark for your use case, check bundle size |
| **Type Safety** | TypeScript support, runtime validation |
| **Developer Experience** | API ergonomics, documentation quality |
| **Maintainability** | Active development, community size, issue response |
| **Learning Curve** | Team familiarity, complexity for the problem |
| **Bundle Size** | Impact on client-side applications |

### 3. **When NOT to Use a Library**
- The problem is trivial (e.g., array filtering)
- The library adds 100KB for a 5-line feature
- You need <1% of the library's functionality
- The library is unmaintained or has known security issues

### 4. **Example Tool Recommendations**

**TypeScript/JavaScript:**
```typescript
// Validation
import { z } from 'zod';
const UserSchema = z.object({ email: z.string().email() });

// Date handling
import { addDays, formatISO } from 'date-fns';

// HTTP client
import ky from 'ky';
const data = await ky.get('api/users').json();
```

**Python:**
```python
# Validation
from pydantic import BaseModel, EmailStr
class User(BaseModel):
    email: EmailStr

# HTTP client
import httpx
async with httpx.AsyncClient() as client:
    response = await client.get('api/users')
```

---

## Architecture Principles

### 1. **Separation of Concerns**

Organize code into distinct layers:

```
├── presentation/     # UI components, API routes
├── services/         # Business logic
├── data/             # Database access, repositories
└── types/            # Shared type definitions
```

**Bad:**
```typescript
// Business logic in UI component
function CheckoutButton() {
  const handleClick = () => {
    const total = cart.items.reduce((sum, item) =>
      sum + item.price * item.quantity, 0
    );
    const tax = total * 0.08;
    const discount = total > 100 ? total * 0.1 : 0;
    // ... more business logic
  };
}
```

**Good:**
```typescript
// Business logic in service
class CartService {
  calculateTotal(cart: Cart): number {
    const subtotal = this.calculateSubtotal(cart);
    const tax = this.calculateTax(subtotal);
    const discount = this.calculateDiscount(subtotal);
    return subtotal + tax - discount;
  }
}

// Clean UI component
function CheckoutButton() {
  const cartService = useCartService();
  const total = cartService.calculateTotal(cart);
}
```

### 2. **Typed Interfaces**

Define clear contracts between modules:

```typescript
// Define interface
interface UserRepository {
  findById(id: string): Promise<User | null>;
  save(user: User): Promise<void>;
}

// Implementation
class DatabaseUserRepository implements UserRepository {
  async findById(id: string): Promise<User | null> {
    // Implementation
  }
}

// Usage (depends on interface, not implementation)
class AuthService {
  constructor(private userRepo: UserRepository) {}
}
```

### 3. **Dependency Direction**

High-level modules should not depend on low-level modules:

**Bad (tight coupling):**
```typescript
// auth-service.ts imports user-service.ts
// user-service.ts imports auth-service.ts
// Circular dependency!
```

**Good (dependency inversion):**
```typescript
// Define interface
interface IUserRepository {
  findByEmail(email: string): Promise<User>;
}

// High-level depends on interface
class AuthService {
  constructor(private userRepo: IUserRepository) {}
}

// Low-level implements interface
class UserService implements IUserRepository {
  async findByEmail(email: string): Promise<User> { }
}
```

### 4. **Avoid Common Anti-Patterns**

- ❌ **God Objects**: Classes that do everything
- ❌ **Circular Dependencies**: A imports B, B imports A
- ❌ **Tight Coupling**: Direct dependencies on concrete implementations
- ❌ **Magic Numbers**: Unexplained constants scattered throughout
- ❌ **Shotgun Surgery**: One change requires updates in many files

---

## Testing Requirements

### 1. **Coverage Standards**
- Minimum 80% code coverage for new code
- 100% coverage for critical paths (auth, payments, security)
- No coverage exemptions without documented justification

### 2. **Test Types**

**Unit Tests** (majority of tests):
```typescript
describe('CartService', () => {
  it('calculates discount for orders over $100', () => {
    const service = new CartService();
    const cart = { items: [{ price: 150, quantity: 1 }] };

    const discount = service.calculateDiscount(cart);

    expect(discount).toBe(15); // 10% of 150
  });
});
```

**Integration Tests** (for interactions):
```typescript
describe('User Registration Flow', () => {
  it('creates user and sends welcome email', async () => {
    const response = await request(app)
      .post('/api/register')
      .send({ email: 'test@example.com', password: 'secure123' });

    expect(response.status).toBe(201);
    expect(mockEmailService).toHaveBeenCalled();
  });
});
```

**End-to-End Tests** (for critical flows):
```typescript
test('user can complete checkout', async ({ page }) => {
  await page.goto('/products');
  await page.click('[data-testid="add-to-cart"]');
  await page.click('[data-testid="checkout"]');
  await page.fill('[name="card"]', '4242424242424242');
  await page.click('[data-testid="submit"]');

  await expect(page.locator('.success-message')).toBeVisible();
});
```

### 3. **Test Quality**
- Test behavior, not implementation
- Include edge cases (empty arrays, null values, boundary conditions)
- Test error cases, not just happy paths
- Use descriptive test names that document requirements
- Mock external dependencies (APIs, databases)

---

## Security Checklist

Every deliverable must address these security concerns:

### 1. **Input Validation**
- ✅ Validate all user input at boundaries
- ✅ Use schema validation (Zod, Pydantic)
- ✅ Enforce type checking
- ✅ Set length limits on strings
- ✅ Validate file uploads (type, size)

**Example:**
```typescript
import { z } from 'zod';

const RegisterSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8).regex(/[A-Z]/).regex(/[0-9]/),
  age: z.number().int().min(13).max(120),
});

// Validate before processing
const validated = RegisterSchema.parse(req.body);
```

### 2. **SQL Injection Prevention**
- ✅ Use parameterized queries or ORM
- ✅ Never concatenate strings in SQL
- ✅ Whitelist dynamic column/table names

**Bad:**
```typescript
const query = `SELECT * FROM users WHERE email = '${email}'`;
```

**Good:**
```typescript
const query = 'SELECT * FROM users WHERE email = $1';
const result = await db.query(query, [email]);
```

### 3. **XSS Prevention**
- ✅ Escape output by default
- ✅ Use safe DOM APIs (textContent, not innerHTML)
- ✅ Sanitize with DOMPurify if HTML needed
- ✅ Set Content Security Policy headers

### 4. **Authentication & Authorization**
- ✅ Hash passwords with bcrypt (cost factor 12+)
- ✅ Verify JWT signatures and expiration
- ✅ Check authorization at resource level, not just route
- ✅ Implement CSRF protection
- ✅ Use httpOnly, secure cookies

### 5. **Secrets Management**
- ✅ Use environment variables
- ✅ Never hardcode API keys or passwords
- ✅ Add .env to .gitignore
- ✅ Rotate secrets regularly

### 6. **Secure Defaults**
- ✅ HTTPS only
- ✅ httpOnly cookies
- ✅ SameSite cookie attribute
- ✅ Rate limiting on auth endpoints
- ✅ Proper CORS configuration

---

## Performance Guidelines

Avoid obvious performance mistakes:

### 1. **Database Queries**
- ✅ Avoid N+1 queries (use eager loading, joins)
- ✅ Add indexes to frequently queried columns
- ✅ Index foreign keys
- ✅ Select only needed columns
- ✅ Paginate large result sets

**Bad (N+1):**
```typescript
const users = await User.findAll();
for (const user of users) {
  const posts = await user.getPosts(); // N queries!
}
```

**Good:**
```typescript
const users = await User.findAll({ include: [Post] }); // 1 query
```

### 2. **Data Structures**
- ✅ Use Set for lookups (O(1) vs O(n) for Array)
- ✅ Use Map for caching
- ✅ Choose appropriate structures for the access pattern

```typescript
// Bad: O(n) lookup
const ids = [1, 2, 3, ...]; // array
if (ids.includes(targetId)) { }

// Good: O(1) lookup
const ids = new Set([1, 2, 3, ...]); // set
if (ids.has(targetId)) { }
```

### 3. **Memory Management**
- ✅ Stream large files (don't load into memory)
- ✅ Paginate large datasets
- ✅ Clean up event listeners
- ✅ Close database connections
- ✅ Clear timers and intervals

### 4. **Algorithm Complexity**
- ✅ Avoid O(n²) in hot paths
- ✅ Use efficient sorting (built-in sort is O(n log n))
- ✅ Consider space-time tradeoffs
- ✅ Profile before complex optimizations

---

## Examples: Good vs Bad

### Example 1: Configuration Loading

❌ **Bad: Manual JSON parsing with type assertion**
```typescript
import { readFileSync } from 'fs';

interface Config {
  apiKey: string;
  timeout: number;
}

function loadConfig(path: string): Config {
  const content = readFileSync(path, 'utf-8');
  return JSON.parse(content) as Config; // No validation!
}
```

**Problems:**
- No runtime validation
- Type assertion is unsafe
- Will crash if structure is wrong
- No error handling

✅ **Good: Schema validation with Zod**
```typescript
import { readFileSync } from 'fs';
import { z } from 'zod';

const ConfigSchema = z.object({
  apiKey: z.string().min(1),
  timeout: z.number().positive(),
});

type Config = z.infer<typeof ConfigSchema>;

function loadConfig(path: string): Config {
  const content = readFileSync(path, 'utf-8');
  const data = JSON.parse(content);
  return ConfigSchema.parse(data); // Throws with helpful error
}
```

---

### Example 2: User Registration

❌ **Bad: No validation, plaintext password**
```typescript
async function registerUser(email: string, password: string) {
  await db.createUser({
    email,
    password, // Stored in plaintext!
  });
}
```

**Problems:**
- No email validation
- No password requirements
- Password stored in plaintext
- No error handling

✅ **Good: Validated input, hashed password**
```typescript
import { z } from 'zod';
import bcrypt from 'bcrypt';

const RegisterSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8).regex(/[A-Z]/).regex(/[0-9]/),
});

async function registerUser(input: unknown) {
  // Validate input
  const { email, password } = RegisterSchema.parse(input);

  // Hash password
  const passwordHash = await bcrypt.hash(password, 12);

  // Store
  await db.createUser({
    email,
    passwordHash,
  });
}
```

---

### Example 3: Database Query

❌ **Bad: SQL injection, N+1 queries**
```typescript
async function getUserPosts(username: string) {
  // SQL injection vulnerability
  const user = await db.query(
    `SELECT * FROM users WHERE username = '${username}'`
  );

  // N+1 query pattern
  const posts = [];
  for (const post of user.post_ids) {
    const postData = await db.query('SELECT * FROM posts WHERE id = ?', [post]);
    posts.push(postData);
  }

  return posts;
}
```

**Problems:**
- SQL injection in first query
- N+1 queries for posts
- No pagination
- Selects all columns

✅ **Good: Parameterized query, single JOIN**
```typescript
async function getUserPosts(username: string, page: number = 1, limit: number = 20) {
  const offset = (page - 1) * limit;

  const query = `
    SELECT p.id, p.title, p.created_at
    FROM posts p
    JOIN users u ON p.user_id = u.id
    WHERE u.username = $1
    ORDER BY p.created_at DESC
    LIMIT $2 OFFSET $3
  `;

  return await db.query(query, [username, limit, offset]);
}
```

---

## Summary

Senior engineer code quality means:

1. ✅ **Best-in-class tools** (Zod, Pydantic, not manual validation)
2. ✅ **Clean architecture** (separation of concerns, typed interfaces)
3. ✅ **Comprehensive tests** (>80% coverage, unit + integration)
4. ✅ **Secure by default** (input validation, parameterized queries, hashed passwords)
5. ✅ **Performant** (avoid N+1 queries, use appropriate data structures)
6. ✅ **Production ready** (error handling, logging, documentation)

When in doubt:
- Research best practices for your language/framework
- Prefer established libraries over custom implementations
- Test thoroughly before marking complete
- Review your code as if you're reviewing a colleague's PR

---

## Related Documentation

- [Security Sentinel Agent](../agents/security-sentinel.md) - Detailed security checks
- [Architecture Strategist Agent](../agents/architecture-strategist.md) - Architecture review
- [Performance Oracle Agent](../agents/performance-oracle.md) - Performance analysis
- [Test Validator Agent](../agents/test-validator.md) - Test coverage validation
- [Security Violations Test Cases](../tests/agents/security-violations-test.md) - Security examples
- [Architecture Violations Test Cases](../tests/agents/architecture-violations-test.md) - Architecture examples
